"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("cross-fetch/polyfill");
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const qs_1 = __importDefault(require("qs"));
const constants_1 = require("./constants");
const ApiHTTPError_1 = require("./errors/ApiHTTPError");
const ApiGraphQLError_1 = require("./errors/ApiGraphQLError");
const ChainHandler_1 = require("./ChainHandler");
const GraphQLController_1 = require("./GraphQLController");
const ErrorHandler_1 = require("./ErrorHandler");
class Api {
    constructor(options) {
        const { workspaceId, headers, catchErrors, transformRequest = [], subscription, } = options;
        let { transformResponse = [] } = options;
        if (catchErrors) {
            transformResponse = [
                (next, data) => __awaiter(this, void 0, void 0, function* () {
                    return this.catchApiGraphQLError(next, data);
                }),
                ...transformResponse,
            ];
        }
        this.url = `${constants_1.API_ENDPOINT}/${workspaceId}`;
        this.headers = headers;
        this.errorHandler = new ErrorHandler_1.ErrorHandler(catchErrors);
        this.requestHandler = ChainHandler_1.ChainHandler.fromArray(transformRequest);
        this.responseHandler = ChainHandler_1.ChainHandler.fromArray(transformResponse);
        this.subscriptionClient = this.prepareSubscriptionClient(workspaceId, subscription);
    }
    static composeHeaders(...headersArr) {
        return __awaiter(this, void 0, void 0, function* () {
            const headersObjects = [];
            const headersPromises = [];
            headersArr.filter(Boolean).forEach(headers => {
                if (typeof headers === 'function') {
                    const headersResult = headers();
                    if (headersResult instanceof Promise) {
                        headersPromises.push(headersResult);
                    }
                    else {
                        headersObjects.push(headersResult);
                    }
                }
                else {
                    headersObjects.push(headers);
                }
            });
            const headersObjectsFromPromises = yield Promise.all(headersPromises);
            const composedHeaders = headersObjects
                .concat(headersObjectsFromPromises)
                .reduce((acc, headers) => {
                return Object.assign(Object.assign({}, acc), headers);
            }, {});
            return composedHeaders;
        });
    }
    request(query, variables, fetchOptions = { headers: {} }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const queryDocument = GraphQLController_1.GraphQLController.getQueryDocument(query);
            const operationDefinition = GraphQLController_1.GraphQLController.getOperationDefinition(queryDocument);
            const isValidOperation = GraphQLController_1.GraphQLController.isOperation('mutation', operationDefinition) ||
                GraphQLController_1.GraphQLController.isOperation('query', operationDefinition);
            if (!isValidOperation) {
                throw new Error('Expected GraphQL query or mutation.');
            }
            const transformedApiRequest = yield this.requestHandler.handle({
                query,
                variables,
                fetchOptions,
            });
            const body = JSON.stringify({
                query: transformedApiRequest.query,
                variables: transformedApiRequest.variables,
            });
            const headers = yield Api.composeHeaders(this.headers, ((_a = transformedApiRequest.fetchOptions) === null || _a === void 0 ? void 0 : _a.headers) || {}, {
                'content-type': 'application/json',
            });
            const httpResponse = yield fetch(this.url, Object.assign(Object.assign({}, transformedApiRequest.fetchOptions), { method: 'POST', body,
                headers }));
            if (ApiHTTPError_1.ApiHTTPError.hasError(httpResponse)) {
                const httpError = new ApiHTTPError_1.ApiHTTPError(transformedApiRequest, httpResponse);
                throw httpError;
            }
            const { response } = yield this.responseHandler.handle({
                request: transformedApiRequest,
                response: yield httpResponse.json(),
            });
            return response;
        });
    }
    query(query, variables, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryDocument = GraphQLController_1.GraphQLController.getQueryDocument(query);
            const operationDefinition = GraphQLController_1.GraphQLController.getOperationDefinition(queryDocument);
            if (!GraphQLController_1.GraphQLController.isOperation('query', operationDefinition)) {
                throw new Error('Expected GraphQL query.');
            }
            return this.request(query, variables, options);
        });
    }
    mutation(query, variables, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (GraphQLController_1.GraphQLController.doesStartWithQuery(query)) {
                throw new Error('Expected GraphQL mutation.');
            }
            const queryDocument = GraphQLController_1.GraphQLController.getQueryDocument(query);
            const operationDefinition = GraphQLController_1.GraphQLController.getOperationDefinition(queryDocument);
            if (GraphQLController_1.GraphQLController.isOperation('subscription', operationDefinition)) {
                throw new Error('Expected GraphQL mutation.');
            }
            if (GraphQLController_1.GraphQLController.isOperation('query', operationDefinition)) {
                query = `mutation ${query}`;
            }
            return this.request(query, variables, options);
        });
    }
    subscription(query, options = {}) {
        const { variables, data, error } = options;
        const result = this.subscriptionClient.request({
            query,
            variables,
        });
        const { unsubscribe } = result.subscribe({
            next(result) {
                if (typeof data === 'function') {
                    data(result);
                }
            },
            error(e) {
                if (typeof error === 'function') {
                    error(e);
                }
            },
        });
        return unsubscribe;
    }
    closeSubscriptionConnection() {
        this.subscriptionClient.close();
    }
    invoke(functionName, request, options) {
        let webhookUrl = `${this.url}/webhook/${functionName}`;
        if (request.path) {
            webhookUrl = `${this.url}/webhook/${request.path}`;
        }
        if (request.data) {
            webhookUrl = `${webhookUrl}${qs_1.default.stringify(request.data, {
                addQueryPrefix: true,
            })}`;
        }
        const fetchOptions = Object.assign(Object.assign({}, (options || {})), { method: request.method });
        return fetch(webhookUrl, fetchOptions);
    }
    catchApiGraphQLError(next, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data.response && ApiGraphQLError_1.ApiGraphQLError.hasError(data.response)) {
                const result = this.errorHandler.handle(new ApiGraphQLError_1.ApiGraphQLError(data.request, data.response), newRequest => {
                    var _a, _b, _c;
                    return this.request(((_a = newRequest) === null || _a === void 0 ? void 0 : _a.query) || data.request.query, ((_b = newRequest) === null || _b === void 0 ? void 0 : _b.variables) || data.request.variables, ((_c = newRequest) === null || _c === void 0 ? void 0 : _c.fetchOptions) || data.request.fetchOptions);
                });
                if (result && result instanceof Promise) {
                    const newResponse = yield result;
                    return next({
                        request: data.request,
                        response: newResponse,
                    });
                }
            }
            return next(data);
        });
    }
    prepareSubscriptionClient(workspaceId, subscriptionOptions = {}) {
        const { connecting, connected, reconnecting, reconnected, disconnected, error, connectionParams, } = subscriptionOptions;
        const subscriptionClient = new subscriptions_transport_ws_1.SubscriptionClient(constants_1.WS_ENDPOINT, {
            lazy: true,
            reconnect: true,
            connectionParams: () => (Object.assign(Object.assign({}, (typeof connectionParams === 'function'
                ? connectionParams()
                : connectionParams)), { workspaceId })),
        }, isomorphic_ws_1.default, []);
        if (typeof connecting === 'function') {
            subscriptionClient.onConnecting(connecting);
        }
        if (typeof connected === 'function') {
            subscriptionClient.onConnected(connected);
        }
        if (typeof reconnecting === 'function') {
            subscriptionClient.onReconnecting(reconnecting);
        }
        if (typeof reconnected === 'function') {
            subscriptionClient.onReconnected(reconnected);
        }
        if (typeof disconnected === 'function') {
            subscriptionClient.onDisconnected(disconnected);
        }
        if (typeof error === 'function') {
            subscriptionClient.onError(error);
        }
        return subscriptionClient;
    }
}
exports.Api = Api;
//# sourceMappingURL=Api.js.map